
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris Personalizable</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #222;
      color: white;
      margin: 0;
      padding: 20px;
    }
    
    .game-container {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }
    
    #tetris {
      border: 3px solid #555;
      background-color: #111;
    }
    
    .panel {
      background-color: #333;
      padding: 15px;
      border-radius: 10px;
      width: 250px;
    }
    
    h1 {
      color: #ff6b6b;
      margin-bottom: 10px;
    }
    
    .controls {
      margin-top: 20px;
    }
    
    button {
      background-color: #4a4a4a;
      color: white;
      border: none;
      padding: 8px 15px;
      margin: 5px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #5a5a5a;
    }
    
    .color-picker {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 15px;
    }
    
    .color-option {
      display: flex;
      align-items: center;
    }
    
    .color-option label {
      width: 100px;
    }
    
    input[type="color"] {
      width: 50px;
      height: 30px;
      cursor: pointer;
      border: 2px solid #555;
      border-radius: 5px;
    }
    
    .palette-controls {
      margin-top: 20px;
      border-top: 1px solid #555;
      padding-top: 15px;
    }
    
    .stats {
      margin-top: 20px;
    }
    
    .stats p {
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <h1>Tetris Personalizable</h1>
  
  <div class="game-container">
    <canvas id="tetris" width="240" height="400"></canvas>
    
    <div class="panel">
      <div class="controls">
        <button id="startBtn">Comenzar</button>
        <button id="pauseBtn">Pausa</button>
      </div>
      
      <div class="stats">
        <p>Nivel: <span id="level">1</span></p>
        <p>Líneas: <span id="lines">0</span></p>
        <p>Puntuación: <span id="score">0</span></p>
      </div>
      
      <div class="color-picker">
        <h3>Personalizar Colores</h3>
        
        <div class="color-option">
          <label>Fondo:</label>
          <input type="color" id="bgColor" value="#111111">
        </div>
        
        <div class="color-option">
          <label>Borde:</label>
          <input type="color" id="borderColor" value="#555555">
        </div>
        
        <div class="color-option">
          <label>Cuadrícula:</label>
          <input type="color" id="gridColor" value="#333333">
        </div>
        
        <h4>Colores de piezas:</h4>
        
        <div class="color-option">
          <label>Pieza I:</label>
          <input type="color" id="colorI" value="#00FFFF">
        </div>
        
        <div class="color-option">
          <label>Pieza O:</label>
          <input type="color" id="colorO" value="#FFFF00">
        </div>
        
        <div class="color-option">
          <label>Pieza T:</label>
          <input type="color" id="colorT" value="#AA00FF">
        </div>
        
        <div class="color-option">
          <label>Pieza S:</label>
          <input type="color" id="colorS" value="#00FF00">
        </div>
        
        <div class="color-option">
          <label>Pieza Z:</label>
          <input type="color" id="colorZ" value="#FF0000">
        </div>
        
        <div class="color-option">
          <label>Pieza J:</label>
          <input type="color" id="colorJ" value="#0000FF">
        </div>
        
        <div class="color-option">
          <label>Pieza L:</label>
          <input type="color" id="colorL" value="#FFA500">
        </div>
      </div>
      
      <div class="palette-controls">
        <h3>Administrar Paletas</h3>
        <input type="text" id="paletteName" placeholder="Nombre de paleta">
        <button id="savePaletteBtn">Guardar Paleta</button>
        <select id="paletteSelect" style="width: 100%; margin-top: 10px;"></select>
        <button id="loadPaletteBtn" style="margin-top: 5px;">Cargar Paleta</button>
        <button id="deletePaletteBtn">Eliminar Paleta</button>
      </div>
    </div>
  </div>

  <script>
    // Elementos del juego
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const scale = 20;
    ctx.scale(scale, scale);

    // Elementos de UI
    const levelDisplay = document.getElementById('level');
    const linesDisplay = document.getElementById('lines');
    const scoreDisplay = document.getElementById('score');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');

    // Selectores de color
    const bgColorPicker = document.getElementById('bgColor');
    const borderColorPicker = document.getElementById('borderColor');
    const gridColorPicker = document.getElementById('gridColor');
    const colorPickers = {
      'I': document.getElementById('colorI'),
      'O': document.getElementById('colorO'),
      'T': document.getElementById('colorT'),
      'S': document.getElementById('colorS'),
      'Z': document.getElementById('colorZ'),
      'J': document.getElementById('colorJ'),
      'L': document.getElementById('colorL')
    };

    // Controles de paleta
    const paletteNameInput = document.getElementById('paletteName');
    const savePaletteBtn = document.getElementById('savePaletteBtn');
    const paletteSelect = document.getElementById('paletteSelect');
    const loadPaletteBtn = document.getElementById('loadPaletteBtn');
    const deletePaletteBtn = document.getElementById('deletePaletteBtn');

    // Variables del juego
    let arena = createMatrix(12, 20);
    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let linesCleared = 0;
    let level = 1;
    let score = 0;
    let gameOver = false;
    let isPaused = false;
    let currentPiece = null;
    let colors = {
      'I': '#00FFFF',
      'O': '#FFFF00',
      'T': '#AA00FF',
      'S': '#00FF00',
      'Z': '#FF0000',
      'J': '#0000FF',
      'L': '#FFA500',
      'background': '#111111',
      'border': '#555555',
      'grid': '#333333'
    };

    // Piezas del Tetris
    const tetrominos = [
      { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], type: 'I' },
      { shape: [[1, 1], [1, 1]], type: 'O' },
      { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], type: 'T' },
      { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], type: 'S' },
      { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], type: 'Z' },
      { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], type: 'J' },
      { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], type: 'L' }
    ];

    // Inicialización
    loadPalettes();
    updateColors();
    setupEventListeners();

    // Funciones del juego
    function createMatrix(w, h) {
      const matrix = [];
      while (h--) matrix.push(new Array(w).fill(0));
      return matrix;
    }

    function createPiece() {
      const rand = Math.floor(Math.random() * tetrominos.length);
      const piece = JSON.parse(JSON.stringify(tetrominos[rand]));
      return {
        shape: piece.shape,
        type: piece.type,
        x: Math.floor(arena[0].length / 2) - Math.floor(piece.shape[0].length / 2),
        y: 0
      };
    }

    function rotate(matrix) {
      const N = matrix.length;
      const result = [];
      for (let i = 0; i < N; i++) {
        result.push([]);
        for (let j = 0; j < N; j++) {
          result[i][j] = matrix[N - j - 1][i];
        }
      }
      return result;
    }

    function rotatePiece() {
      if (gameOver || isPaused) return;
      
      const originalShape = currentPiece.shape;
      const rotated = rotate(currentPiece.shape);
      
      if (currentPiece.type === 'O') return;
      
      currentPiece.shape = rotated;
      if (collide(arena, currentPiece)) {
        currentPiece.shape = originalShape;
      }
    }

    function collide(arena, piece) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x] !== 0 &&
              (arena[y + piece.y] === undefined || 
               arena[y + piece.y][x + piece.x] === undefined || 
               arena[y + piece.y][x + piece.x] !== 0)) {
            return true;
          }
        }
      }
      return false;
    }

    function merge(arena, piece) {
      piece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            arena[y + piece.y][x + piece.x] = piece.type;
          }
        });
      });
    }

    function clearLines() {
      outer: for (let y = arena.length - 1; y >= 0; y--) {
        for (let x = 0; x < arena[y].length; x++) {
          if (arena[y][x] === 0) {
            continue outer;
          }
        }
        
        const row = arena.splice(y, 1)[0];
        arena.unshift(new Array(row.length).fill(0));
        linesCleared++;
        
        // Calcular puntuación
        const linePoints = [0, 40, 100, 300, 1200];
        score += linePoints[1] * level;
        
        linesDisplay.textContent = linesCleared;
        scoreDisplay.textContent = score;

        if (linesCleared % 10 === 0 && level < 99) {
          level++;
          dropInterval = Math.max(100, dropInterval - 50);
          levelDisplay.textContent = level;
        }
        
        y++;
      }
    }

    function draw() {
      // Fondo
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Cuadrícula
      ctx.strokeStyle = colors.grid;
      ctx.lineWidth = 0.05;
      for (let x = 0; x < arena[0].length; x++) {
        for (let y = 0; y < arena.length; y++) {
          ctx.strokeRect(x, y, 1, 1);
        }
      }
      
      // Arena
      drawMatrix(arena, { x: 0, y: 0 });
      
      // Pieza actual
      if (currentPiece) {
        drawMatrix(currentPiece.shape, currentPiece, currentPiece.type);
      }
      
      // Borde
      ctx.strokeStyle = colors.border;
      ctx.lineWidth = 0.2;
      ctx.strokeRect(0, 0, arena[0].length, arena.length);
    }

    function drawMatrix(matrix, offset, type = null) {
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            ctx.fillStyle = colors[type || value];
            ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
            
            // Borde para mejor visibilidad
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.05;
            ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
          }
        });
      });
    }

    function update(time = 0) {
      if (gameOver || isPaused) {
        lastTime = time;
        requestAnimationFrame(update);
        return;
      }
      
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;

      if (dropCounter > dropInterval) {
        drop();
        dropCounter = 0;
      }

      draw();
      requestAnimationFrame(update);
    }

    function move(dir) {
      if (gameOver || isPaused) return;
      
      currentPiece.x += dir;
      if (collide(arena, currentPiece)) {
        currentPiece.x -= dir;
      }
    }

    function drop() {
      currentPiece.y++;
      if (collide(arena, currentPiece)) {
        currentPiece.y--;
        merge(arena, currentPiece);
        clearLines();
        currentPiece = createPiece();
        if (collide(arena, currentPiece)) {
          gameOver = true;
          alert("¡Game Over!");
          startBtn.textContent = 'Reiniciar';
          startBtn.style.display = 'block';
        }
      }
    }

    // Funciones de personalización
    function updateColors() {
      // Actualizar colores de las piezas
      for (const [type, picker] of Object.entries(colorPickers)) {
        colors[type] = picker.value;
      }
      
      // Actualizar colores del tablero
      colors.background = bgColorPicker.value;
      colors.border = borderColorPicker.value;
      colors.grid = gridColorPicker.value;
      
      // Aplicar cambios visuales
      canvas.style.backgroundColor = colors.background;
      canvas.style.borderColor = colors.border;
      draw();
    }

    // Funciones de paletas de colores
    function savePalette() {
      const name = paletteNameInput.value.trim();
      if (!name) return;
      
      const palettes = getPalettes();
      palettes[name] = {
        pieceColors: {
          'I': colorPickers['I'].value,
          'O': colorPickers['O'].value,
          'T': colorPickers['T'].value,
          'S': colorPickers['S'].value,
          'Z': colorPickers['Z'].value,
          'J': colorPickers['J'].value,
          'L': colorPickers['L'].value
        },
        boardColors: {
          background: bgColorPicker.value,
          border: borderColorPicker.value,
          grid: gridColorPicker.value
        }
      };
      
      localStorage.setItem('tetrisPalettes', JSON.stringify(palettes));
      loadPalettes();
      paletteNameInput.value = '';
    }

    function loadPalettes() {
      const palettes = getPalettes();
      paletteSelect.innerHTML = '';
      
      for (const name in palettes) {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        paletteSelect.appendChild(option);
      }
    }

    function loadPalette() {
      const name = paletteSelect.value;
      if (!name) return;
      
      const palettes = getPalettes();
      const palette = palettes[name];
      
      if (palette) {
        // Cargar colores de piezas
        for (const [type, color] of Object.entries(palette.pieceColors)) {
          colorPickers[type].value = color;
          colors[type] = color;
        }
        
        // Cargar colores del tablero
        bgColorPicker.value = palette.boardColors.background;
        borderColorPicker.value = palette.boardColors.border;
        gridColorPicker.value = palette.boardColors.grid;
        
        colors.background = palette.boardColors.background;
        colors.border = palette.boardColors.border;
        colors.grid = palette.boardColors.grid;
        
        updateColors();
      }
    }

    function deletePalette() {
      const name = paletteSelect.value;
      if (!name) return;
      
      const palettes = getPalettes();
      delete palettes[name];
      
      localStorage.setItem('tetrisPalettes', JSON.stringify(palettes));
      loadPalettes();
    }

    function getPalettes() {
      return JSON.parse(localStorage.getItem('tetrisPalettes')) || {};
    }

    // Event listeners
    function setupEventListeners() {
      startBtn.addEventListener('click', () => {
        if (gameOver) {
          resetGame();
        } else {
          startGame();
        }
      });
      
      pauseBtn.addEventListener('click', () => {
        isPaused = !isPaused;
        pauseBtn.textContent = isPaused ? 'Continuar' : 'Pausa';
      });
      
      // Selectores de color
      bgColorPicker.addEventListener('input', updateColors);
      borderColorPicker.addEventListener('input', updateColors);
      gridColorPicker.addEventListener('input', updateColors);
      for (const picker of Object.values(colorPickers)) {
        picker.addEventListener('input', updateColors);
      }
      
      // Paletas
      savePaletteBtn.addEventListener('click', savePalette);
      loadPaletteBtn.addEventListener('click', loadPalette);
      deletePaletteBtn.addEventListener('click', deletePalette);
      
      // Controles del juego
      document.addEventListener('keydown', event => {
        if (gameOver || isPaused) return;
        
        switch(event.key) {
          case 'ArrowLeft': move(-1); break;
          case 'ArrowRight': move(1); break;
          case 'ArrowDown': drop(); break;
          case 'ArrowUp': rotatePiece(); break;
        }
      });
    }

    function startGame() {
      arena = createMatrix(12, 20);
      dropCounter = 0;
      dropInterval = 1000;
      lastTime = 0;
      linesCleared = 0;
      level = 1;
      score = 0;
      gameOver = false;
      isPaused = false;
      
      levelDisplay.textContent = level;
      linesDisplay.textContent = linesCleared;
      scoreDisplay.textContent = score;
      
      currentPiece = createPiece();
      startBtn.style.display = 'none';
      update();
    }

    function resetGame() {
      startGame();
      startBtn.textContent = 'Comenzar';
    }

    // Inicializar UI
    startBtn.style.display = 'block';
    pauseBtn.style.display = 'block';
  </script>
</body>
  </html>
