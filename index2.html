<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tetris Móvil</title>
  <style>
    /* (Mantener los mismos estilos CSS anteriores) */
  </style>
</head>
<body>
  <!-- (Mantener la misma estructura HTML anterior) -->

  <script>
    // (Mantener todas las declaraciones iniciales anteriores)

    // Nuevas variables para el control táctil mejorado
    let touchStartPieceY = 0;
    let isTouchingPiece = false;
    let touchIsRotate = false;
    const pieceHeightThreshold = 0.7; // 70% de la altura de la pieza para considerar "parte inferior"

    // Modificar la función handleTouchStart
    function handleTouchStart(e) {
      if (gameOver || isPaused) return;
      
      e.preventDefault();
      const touchX = e.touches[0].clientX;
      const touchY = e.touches[0].clientY;
      const rect = canvas.getBoundingClientRect();
      
      // Convertir coordenadas de pantalla a coordenadas del juego
      const gameX = Math.floor((touchX - rect.left) / scale);
      const gameY = Math.floor((touchY - rect.top) / scale);
      
      // Verificar si el toque está dentro de la pieza actual
      isTouchingPiece = false;
      for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
          if (currentPiece.shape[y][x] !== 0 && 
              gameX === currentPiece.x + x && 
              gameY === currentPiece.y + y) {
            isTouchingPiece = true;
            touchStartPieceY = y / currentPiece.shape.length; // Porcentaje de altura en la pieza
            break;
          }
        }
        if (isTouchingPiece) break;
      }
      
      touchStartX = touchX;
      touchStartY = touchY;
      touchMoved = false;
      touchIsRotate = !isTouchingPiece; // Si no toca la pieza, es para rotar
    }

    // Modificar la función handleTouchMove
    function handleTouchMove(e) {
      if (gameOver || isPaused) return;
      
      e.preventDefault();
      const touchX = e.touches[0].clientX;
      const touchY = e.touches[0].clientY;
      const deltaX = touchX - touchStartX;
      const deltaY = touchY - touchStartY;
      
      // Solo actuar después de un umbral mínimo de movimiento
      if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
        touchMoved = true;
        
        if (touchIsRotate) {
          // Si era un toque para rotar pero se movió, cancelar
          touchIsRotate = false;
        } else if (isTouchingPiece) {
          const now = Date.now();
          if (now - lastMoveTime > moveDelay) {
            // Mover horizontalmente si el toque fue en cualquier parte de la pieza
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
              move(deltaX > 0 ? 1 : -1);
            } 
            // Mover verticalmente solo si el toque fue en la parte inferior de la pieza
            else if (deltaY > 0 && touchStartPieceY > pieceHeightThreshold) {
              fastDrop = true;
            }
            
            lastMoveTime = now;
          }
        }
        
        touchStartX = touchX;
        touchStartY = touchY;
      }
    }

    // Modificar la función handleTouchEnd
    function handleTouchEnd(e) {
      if (gameOver || isPaused) return;
      
      e.preventDefault();
      
      // Si fue un toque sin movimiento y era para rotar
      if (!touchMoved && touchIsRotate) {
        rotatePiece();
      }
      
      // Resetear variables
      isTouchingPiece = false;
      touchIsRotate = false;
      fastDrop = false;
    }

    // (Mantener el resto de las funciones igual)
  </script>
</body>
</html><!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tetris Móvil</title>
  <style>
    /* (Mantener los mismos estilos CSS anteriores) */
  </style>
</head>
<body>
  <!-- (Mantener la misma estructura HTML anterior) -->

  <script>
    // (Mantener todas las declaraciones iniciales anteriores)

    // Nuevas variables para el control táctil mejorado
    let touchStartPieceY = 0;
    let isTouchingPiece = false;
    let touchIsRotate = false;
    const pieceHeightThreshold = 0.7; // 70% de la altura de la pieza para considerar "parte inferior"

    // Modificar la función handleTouchStart
    function handleTouchStart(e) {
      if (gameOver || isPaused) return;
      
      e.preventDefault();
      const touchX = e.touches[0].clientX;
      const touchY = e.touches[0].clientY;
      const rect = canvas.getBoundingClientRect();
      
      // Convertir coordenadas de pantalla a coordenadas del juego
      const gameX = Math.floor((touchX - rect.left) / scale);
      const gameY = Math.floor((touchY - rect.top) / scale);
      
      // Verificar si el toque está dentro de la pieza actual
      isTouchingPiece = false;
      for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
          if (currentPiece.shape[y][x] !== 0 && 
              gameX === currentPiece.x + x && 
              gameY === currentPiece.y + y) {
            isTouchingPiece = true;
            touchStartPieceY = y / currentPiece.shape.length; // Porcentaje de altura en la pieza
            break;
          }
        }
        if (isTouchingPiece) break;
      }
      
      touchStartX = touchX;
      touchStartY = touchY;
      touchMoved = false;
      touchIsRotate = !isTouchingPiece; // Si no toca la pieza, es para rotar
    }

    // Modificar la función handleTouchMove
    function handleTouchMove(e) {
      if (gameOver || isPaused) return;
      
      e.preventDefault();
      const touchX = e.touches[0].clientX;
      const touchY = e.touches[0].clientY;
      const deltaX = touchX - touchStartX;
      const deltaY = touchY - touchStartY;
      
      // Solo actuar después de un umbral mínimo de movimiento
      if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
        touchMoved = true;
        
        if (touchIsRotate) {
          // Si era un toque para rotar pero se movió, cancelar
          touchIsRotate = false;
        } else if (isTouchingPiece) {
          const now = Date.now();
          if (now - lastMoveTime > moveDelay) {
            // Mover horizontalmente si el toque fue en cualquier parte de la pieza
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
              move(deltaX > 0 ? 1 : -1);
            } 
            // Mover verticalmente solo si el toque fue en la parte inferior de la pieza
            else if (deltaY > 0 && touchStartPieceY > pieceHeightThreshold) {
              fastDrop = true;
            }
            
            lastMoveTime = now;
          }
        }
        
        touchStartX = touchX;
        touchStartY = touchY;
      }
    }

    // Modificar la función handleTouchEnd
    function handleTouchEnd(e) {
      if (gameOver || isPaused) return;
      
      e.preventDefault();
      
      // Si fue un toque sin movimiento y era para rotar
      if (!touchMoved && touchIsRotate) {
        rotatePiece();
      }
      
      // Resetear variables
      isTouchingPiece = false;
      touchIsRotate = false;
      fastDrop = false;
    }

    // (Mantener el resto de las funciones igual)
  </script>
</body>
</html>
